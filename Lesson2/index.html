<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Chase</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Inter:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Abel&family=Montserrat:wght@400;700&family=Poppins:wght@400;700&family=Noto+Sans:wght@400;700&family=Raleway:wght@400;700&family=Source+Sans+Pro:wght@400;700&family=Merriweather:wght@400;700&family=Oswald:wght@400;700&family=Barlow:wght@400;700&family=Assistant:wght@400;700&family=Urbanist:wght@400;700&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
<style>
    body {
        margin: 0;
        overflow: hidden;
        position: relative;
		background-color:black;
	}
/*--------------------------*/
/* COLUMN 1 CSS             */
/*--------------------------*/
    #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 0;
    }
    #playerGif {
        position: absolute;
        top: -50px;
        left: 0;
        z-index: 2;
		image-rendering: pixelated;
		image-rendering: -moz-crisp-edges;
		image-rendering: crisp-edges;
    }
    #enemyGif {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2;
		image-rendering: pixelated;
		image-rendering: -moz-crisp-edges;
		image-rendering: crisp-edges;
    }
    #topdownRoom {
        position: absolute;
        top: 0px;
        left: 0;
        z-index: 1;
		width:768px;
		height:512px;
		image-rendering: pixelated;
		image-rendering: -moz-crisp-edges;
		image-rendering: crisp-edges;
		opacity:1;
    }
    canvas {
        display: block;
        margin: 0 auto;
    }
    #roomArt {
        margin: 0;
        overflow: hidden;
        position: relative;
		width:768px;
		height:420px;
		top:512px;
    }
	
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
    }
	
    .container {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        width:100%;
        margin: 0 auto;
    }
    .column {
        box-sizing: border-box;
        margin: 0;
        overflow: hidden;
        position: relative;
    }
    @media screen and (max-width: 768px) {
        .column {
            flex-basis: 48%;
        }
    }
    @media screen and (max-width: 480px) {
        .column {
            flex-basis: 100%;
        }
    }
	
/*--------------------------*/
/* COLUMN 2 CSS             */
/*--------------------------*/
	#column2 {
		background-color:#000;
	}

	#logo {
		width:500px;
		position:fixed;
		z-index:10;
		margin-left:-100px;
		margin-top:-40px;
		
	}
	
	#status {
        text-align: center;
	}
	
	#avatar {
		margin-top:200px;
		width:150px;
		image-rendering: pixelated;
		image-rendering: -moz-crisp-edges;
		image-rendering: crisp-edges;
	}
	
	#name {
		font-family:abel;
		font-size:30px;
		color:#974818;
	}
	
	#hp {
		font-family:abel;
		font-size:20px;
		color:white;
	}
	
	#healthbar {
		width:100px;
		height:20px;
		background-color:#3e2011;
		display:inline-block;
		border:4px solid #603535;
		border-radius:10px;
	}
	
	.fa-heart {
		color:#773419;
		margin-right:10px;
	}
	
	#hplabel {
		width:100px;
		height:20px;
		display:inline-block;
		vertical-align:top;
	}
	
	#health {
		width:50px;
		height:20px;
		background-color:#7b420e;
		border-radius:5px;
	}
</style>

<style>
/*--------------------------*/
/* COLUMN 3 CSS             */
/*--------------------------*/

#column3 {

}

/*--------------------------*/
/* MINIMAP CSS             */
/*--------------------------*/
	#minimapCanvas {
		border: 1px solid black;
		background-color: #808080; /* Gray color */
		display: block;
		margin: 0 auto;
	}
	
	#minimapAvatar {
		position:absolute;
		top:182px;
		left:360px;
		width:64px;
		image-rendering: pixelated;
		image-rendering: -moz-crisp-edges;
		image-rendering: crisp-edges;
	}
	
	#dungeon_wall {
		display:none;
	}
	
	#dungeon_floor {
		display:none;
	}
</style>

<style>
/*--------------------------*/
/* TERMINAL CSS             */
/*--------------------------*/
    #terminal {
        font-family: monospace;
        font-size: 16px;
        line-height: 1.5;
        background-color: black;
        color: white;
        padding: 10px;
        margin: 0;
        width: 100%;
        height: 365px;
        overflow-y: auto;
    }
    #input {
        font-family: monospace;
        font-size: 16px;
        line-height: 1.5;
        background-color: black;
        color: white;
        border: none;
        padding: 10px;
        margin: 0;
        width: calc(100% - 20px); /* Adjust width to account for padding */
        outline: none; /* Remove default focus outline */
    }
	
/*--------------------------*/
/* TEXT CSS             	*/
/*--------------------------*/
	.room_name {
		color:orange;
	}

	.room_description {
		color:gray;
	}
</style>
</head>
<body>
<div class="container">
    <div class="column" style="width:768px; height:960px;">
		<canvas id="gameCanvas" width="768" height="512"></canvas>
		<img id="playerGif" src="player-south.png" alt="Player GIF">
		<img id="enemyGif" src="enemy-south.png" alt="Enemy GIF">
		<img id="topdownRoom" src="mapart.png" alt="Top Down Room">
		<img id="roomArt" src="skeleton-warrior3.png" alt="Top Down Room">
    </div>
    <div id="column2" class="column" style="width:300px;">
		<img id="logo" src="dungeon_chase3.png" alt="logo">
		<div id="status">
			<img id="avatar" src="player-south.png" alt="Player Avatar">
			<div id="name">Joe Cur-Sed</div>
			<div id="hp"><div id="hplabel"><i class="fas fa-heart"></i><i class="fas fa-heart"></i><i class="fas fa-heart"></i></div><div id="healthbar"><div id="health"></div></div></div>
		</div>
        <img id="card" src="card_skeleton.jpg" alt="Card" style="width:300px;">
    </div>
    <div id="column3" class="column" style="flex: 1;">
		<img id="minimapAvatar" src="player-south.png" alt="Minimap Avatar">
		<canvas id="minimapCanvas" width="900" height="500"></canvas>
		<img id="dungeon_wall" src="dungeon_wall3.png" alt="wall">
		<img id="dungeon_floor" src="dungeon_wall2.png" alt="floor">
		<div id="terminal"></div>
		<input type="text" id="input">
    </div>
	
</div>





<script>
	var game_over = false;

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
	
	const playerGif = document.getElementById("playerGif");
	const enemyGif = document.getElementById("enemyGif");
	
	const minimapAvatarGif = document.getElementById("minimapAvatar");

    const character = {
        width: 16,
        height: 32,
    };

    const player = {
        x: 300,
        y: 300,
        width: 16,
        height: 32,
        speed: 3,
        dx: 0,
        dy: 0,
        prevDx: 0,
        prevDy: 0
    };

    const enemy = {
        x: canvas.width - 300,
        y: canvas.height - 300,
        width: 16,
        height: 32,
        speed: 1,
        dx: 0,
        dy: 0,
        prevDx: 0,
        prevDy: 0
    };
	
    const yellowPixels = [];

    const img = new Image();
    img.src = 'map.png'; // Provide the path to your image here

    img.onload = function() {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        detectYellowPixels();
		gameLoop();
    };

    function detectYellowPixels() {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
		console.log("yellow pixels start");

        for (let i = 0; i < data.length; i += 128) {
            const red = data[i];
            const green = data[i + 1];
            const blue = data[i + 2];
			
			//console.log("inini red:"+red+ " green:"+green + "blue:"+blue);

            if (red === 255 && green === 255 && blue === 0) {
                const x = (i / 4) % canvas.width + 32;
                const y = Math.floor(i / 4 / canvas.width) + 32;
				
				let yellowPixel = {
					x: x,
					y: y,
					width: 32,
					height: 32
				};
				
                yellowPixels.push(yellowPixel);
            }
        }
    }

    const greenPixels = []; // Array to store greenPixel coordinates

    const greenPixelsCount = 0; // Number of greenPixels

    // Generate random greenPixels
    for (let i = 0; i < greenPixelsCount; i++) {
        let greenPixel = {
            x: Math.floor(Math.random() * (canvas.width - 20)) + 10,
            y: Math.floor(Math.random() * (canvas.height - 20)) + 10,
            width: Math.floor(Math.random() * 16) + 16,
            height: Math.floor(Math.random() * 16) + 16
        };
        greenPixels.push(greenPixel);
    }

    function drawPlayer() {
        ctx.fillStyle = "rgba(0, 0, 0, 0)" // "blue"; // Adjust the alpha value (last parameter) for transparency
        ctx.fillRect(player.x, player.y, player.width, player.height);
    }

    function drawEnemy() {
        ctx.fillStyle = "rgba(0, 0, 0, 0)"  // "red";
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
    }
	
    function drawYellowPixels() {
        ctx.fillStyle = "yellow";
        yellowPixels.forEach(yellowPixel => {
            ctx.fillRect(yellowPixel.x, yellowPixel.y, yellowPixel.width, yellowPixel.height);
        });
    }

    function drawGreenPixels() {
        ctx.fillStyle = "green";
        greenPixels.forEach(greenPixel => {
            ctx.fillRect(greenPixel.x, greenPixel.y, greenPixel.width, greenPixel.height);
        });
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function movePlayer() {
        player.x += player.dx;
        player.y += player.dy;

        // Check collision with greenPixels
        if (checkGreenCollision(player.x, player.y, player.width, player.height)) {
            player.x -= player.dx;
            player.y -= player.dy;
            player.dx = 0;
            player.dy = 0;
        }
		
        // Check collision with yellow pixels
        if (checkYellowCollision(player.x, player.y, player.width, player.height)) {
            player.x -= player.dx;
            player.y -= player.dy;
            player.dx = 0;
            player.dy = 0;
        }
		
		// Update position of the player GIF
        playerGif.style.left = player.x + "px";
        playerGif.style.top = player.y + "px";
		console.log (player.x + "px, " + player.y + "px");
		
        // Update player GIF based on movement direction
        if (player.dx > 0 && player.dx !== player.prevDx) {
            playerGif.src = "player-east.png";
            player.prevDx = player.dx;
            player.prevDy = 0;
        } else if (player.dx < 0 && player.dx !== player.prevDx) {
            playerGif.src = "player-west.png";
            player.prevDx = player.dx;
            player.prevDy = 0;
        } else if (player.dy > 0 && player.dy !== player.prevDy) {
            playerGif.src = "player-south.png";
            player.prevDy = player.dy;
            player.prevDx = 0;
        } else if (player.dy < 0 && player.dy !== player.prevDy) {
            playerGif.src = "player-north.png";
            player.prevDy = player.dy;
            player.prevDx = 0;
        }
    }

    function moveEnemy() {
        // Simple chase algorithm
        if (enemy.x <= player.x) {
            if (!checkYellowCollision(enemy.x + enemy.speed, enemy.y, enemy.width, enemy.height) && !checkGreenCollision(enemy.x + enemy.speed, enemy.y, enemy.width, enemy.height)) {
                enemy.x += enemy.speed;
            }
        } else {
            if (!checkYellowCollision(enemy.x - enemy.speed, enemy.y, enemy.width, enemy.height) && !checkGreenCollision(enemy.x - enemy.speed, enemy.y, enemy.width, enemy.height)) {
                enemy.x -= enemy.speed;
            }
        }

        if (enemy.y <= player.y) {
            if (!checkYellowCollision(enemy.x, enemy.y + enemy.speed, enemy.width, enemy.height) && !checkGreenCollision(enemy.x, enemy.y + enemy.speed, enemy.width, enemy.height)) {
                enemy.y += enemy.speed;
            }
        } else {
            if (!checkYellowCollision(enemy.x, enemy.y - enemy.speed, enemy.width, enemy.height) && !checkGreenCollision(enemy.x, enemy.y - enemy.speed, enemy.width, enemy.height)) {
                enemy.y -= enemy.speed;
            }
        }
		
		// Update position of the enemy GIF
        enemyGif.style.left = enemy.x + "px";
        enemyGif.style.top = enemy.y + "px";
		
        if (enemy.dx > 0 && enemy.dx !== enemy.prevDx) {
            enemyGif.src = "enemy-east.png";
            enemy.prevDx = enemy.dx;
            enemy.prevDy = 0;
        } else if (enemy.dx < 0 && enemy.dx !== enemy.prevDx) {
            enemyGif.src = "enemy-west.png";
            enemy.prevDx = enemy.dx;
            enemy.prevDy = 0;
        } else if (enemy.dy > 0 && enemy.dy !== enemy.prevDy) {
            enemyGif.src = "enemy-south.png";
            enemy.prevDy = enemy.dy;
            enemy.prevDx = 0;
        } else if (enemy.dy < 0 && enemy.dy !== enemy.prevDy) {
            enemyGif.src = "enemy-north.png";
            enemy.prevDy = enemy.dy;
            enemy.prevDx = 0;
        }
    }

    function checkYellowCollision(x, y, width, height) {
        if (checkIsDotYellow(x, y) || checkIsDotYellow(x + width, y) || checkIsDotYellow(x, y + height) || checkIsDotYellow(x + width, y + height)) {
			return true;
		}
		return false;
    }
	
	function checkIsDotYellow(x, y) {
		const imageData = ctx.getImageData(x, y, 1, 1);
		const data = imageData.data;
		const red = data[0];
        const green = data[1];
        const blue = data[2];
        if (red === 255 && green === 255 && blue === 0) {
			return true;
		}
		return false;
	}

    function checkGreenCollision(x, y, width, height) {
        // Check collision with greenPixels
        for (let i = 0; i < greenPixels.length; i++) {
            if (
                x < greenPixels[i].x + greenPixels[i].width &&
                x + width > greenPixels[i].x &&
                y < greenPixels[i].y + greenPixels[i].height &&
                y + height > greenPixels[i].y
            ) {
                return true;
            }
        }

        // Check collision with canvas boundaries
        if (x < 0 || x + width > canvas.width || y < 0 || y + height > canvas.height) {
            return true;
        }

        return false;
    }

    function checkPlayerEnemyCollision() {
        if (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y
        ) {
			game_over = true;
            alert("Game Over!");
            // You can add game over logic here
        }
    }

    function gameLoop() {
		console.log("game_over:" + game_over);
		if (game_over == false) {
			//clearCanvas();
			// drawGreenPixels();
			drawPlayer();
			drawEnemy();
			movePlayer();
			moveEnemy();
			checkPlayerEnemyCollision();
			requestAnimationFrame(gameLoop);
		}
    }

    document.addEventListener("keydown", function (event) {
        switch (event.key) {
            case "w":
                player.dy = -player.speed;
                break;
            case "a":
                player.dx = -player.speed;
                break;
            case "s":
                player.dy = player.speed;
                break;
            case "d":
                player.dx = player.speed;
                break;
        }
    });

    document.addEventListener("keyup", function (event) {
        switch (event.key) {
            case "w":
            case "s":
                player.dy = 0;
                break;
            case "a":
            case "d":
                player.dx = 0;
                break;
        }
    });
</script>
<script>
/*--------------------------*/
/* MINIMAP JAVASCRIPT       */
/*--------------------------*/
    // Example room data (coordinates as keys, room info as values)
    const rooms = {
        "0,0": {"name" : "Starting Room", "description" : "You are in a room in a dungeon."},
        "1,0": {"name" : "Hallway", "description" : "You are in a hallway."},
        "1,1": {"name" : "Treasure Room", "description" : "You are in a treasure room filled with treasure."},
        "0,1": {"name" : "Empty Room", "description" : "You are in an empty room in a dungeon."},
        "-1,0": {"name" : "Monster Room", "description" : "You are in a monster in a dungeon."}
        // Add more rooms as needed
    };

    // Player position
    let playerPosition = { x: -1, y: 0 };	
	

	
        class DungeonCrawler {
            constructor(width, height, canvas) {
                this.width = width;
                this.height = height;
                this.cellSize = canvas.width / width;
                this.playerX = 0; // Math.floor(width / 2);
                this.playerY = 0; // Math.floor(height / 2);
                // this.rooms = {}; // Dictionary to store room information
                this.rooms = rooms;
				this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            }


            movePlayer(dx, dy) {
                const newX = this.playerX + dx;
                const newY = this.playerY + dy;
                
                // Check if the new position is within the bounds
                if (newX >= -this.width && newX < this.width && newY >= -this.height && newY < this.height) {
                    // Check if the new position is within a room
                    if (this.rooms[`${newX},${newY}`]) {
                        // Check if there is an exit in that direction
                        if (dx !== 0 && this.rooms[`${newX - dx},${newY}`]) {
                            this.playerX = newX;
                        } else if (dy !== 0 && this.rooms[`${newX},${newY - dy}`]) {
                            this.playerY = newY;
                        }
						console.log("++ " + newX + ", " + newY + " - " + this.rooms[`${newX},${newY}`].name + " - " + this.rooms[`${newX},${newY}`].description);
						terminal.print("<span class='room_name'>"+this.rooms[`${newX},${newY}`].name+"</span>");
						terminal.print("<span class='room_description'>"+this.rooms[`${newX},${newY}`].description+"</span>");
						terminal.print("");
					}
                    this.render();
                }
            }

            generateMap() {
                // Implement your map generation algorithm here
                // For example, using a binary tree approach
                // This is just a simple example
                for (let x = 0; x < this.width; x++) {
                    for (let y = 0; y < this.height; y++) {
                        if (Math.random() < 0.3) {
							var room = {}
							room.description = "description "+ x + " " +y;
                            this.rooms[`${x},${y}`] = room;
                        }
						
                    }
                }
				
            }

            getMap() {
                return this.rooms;
            }

            render() {
                const map = this.getMap();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const offsetX = (this.canvas.width / 2) - (this.playerX * this.cellSize);
                const offsetY = (this.canvas.height / 2) - (this.playerY * this.cellSize);

                for (let y = -this.height; y < this.height; y++) {
                    for (let x = -this.width; x < this.width; x++) {
                        const cellX = x * this.cellSize + offsetX;
                        const cellY = y * this.cellSize + offsetY;
                        if (map[`${x},${y}`]) {
                            this.ctx.fillStyle = 'white'; // Room present
                            this.ctx.fillRect(cellX- (this.cellSize), cellY - (this.cellSize), this.cellSize, this.cellSize);
							const img = document.getElementById("dungeon_floor");
							this.ctx.drawImage(img, cellX - (this.cellSize ), cellY - (this.cellSize), this.cellSize, this.cellSize); 
                        }
						else {
							this.ctx.fillStyle = 'gray'; // Room present
                            this.ctx.fillRect(cellX- (this.cellSize), cellY- (this.cellSize), this.cellSize, this.cellSize);
							const img = document.getElementById("dungeon_wall");
							this.ctx.drawImage(img, cellX- (this.cellSize), cellY- (this.cellSize), this.cellSize, this.cellSize); 
						}
                    }
                }

                const playerX = (this.canvas.width / 2);
                const playerY = (this.canvas.height / 2);
                this.ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Player position
                this.ctx.fillRect(playerX, playerY, this.cellSize, this.cellSize);
            }
        }

        const canvasMinimap = document.getElementById('minimapCanvas');
        const dungeonCrawler = new DungeonCrawler(10, 10, canvasMinimap);
        // dungeonCrawler.generateMap();
        dungeonCrawler.render();

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
					minimapAvatarGif.src = "player-north.png";
                    dungeonCrawler.movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    minimapAvatarGif.src = "player-south.png";
					dungeonCrawler.movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    minimapAvatarGif.src = "player-west.png";
					dungeonCrawler.movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    minimapAvatarGif.src = "player-east.png";
					dungeonCrawler.movePlayer(1, 0);
                    break;
                default:
                    break;
            }
        });
    </script>

<script>
/*--------------------------*/
/* TERMINAL JAVASCRIPT       */
/*--------------------------*/
class Terminal {
    constructor(elementId) {
        this.terminalElement = document.getElementById(elementId);
        this.inputElement = document.getElementById('input');
        this.scrollThreshold = 90; // Percentage of scroll before auto-scrolling
        this.commandHistory = [];
        this.currentCommandIndex = -1;

        // Handle enter key press
        this.inputElement.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                const command = this.inputElement.value.trim();
                this.inputElement.value = '';
                if (command) {
                    this.commandHistory.push(command);
                    this.currentCommandIndex = -1;
                    this.print(`> ${command}`);
                    this.handleCommand(command);
                }
            } else if (event.key === 'ArrowUp') {
                this.navigateCommandHistory(-1);
            } else if (event.key === 'ArrowDown') {
                this.navigateCommandHistory(1);
            }
        });

        // Focus on input when terminal is clicked
        this.terminalElement.addEventListener('click', () => {
            this.inputElement.focus();
        });
    }

    print(message) {
        this.terminalElement.innerHTML += message + '<br>';
        this.scrollToBottom();
    }

    handleCommand(command) {
        // Implement your command handling logic here
        // Example: echo command
        this.print(command);
    }

    scrollToBottom() {
        this.terminalElement.scrollTop = this.terminalElement.scrollHeight;
    }

    navigateCommandHistory(direction) {
        if (this.commandHistory.length === 0) return;

        if (this.currentCommandIndex === -1) {
            this.currentCommandIndex = this.commandHistory.length - 1;
        } else {
            this.currentCommandIndex += direction;
            if (this.currentCommandIndex < -1) {
                this.currentCommandIndex = -1;
                return;
            } else if (this.currentCommandIndex >= this.commandHistory.length) {
                this.currentCommandIndex = this.commandHistory.length - 1;
                return;
            }
        }
        this.inputElement.value = this.commandHistory[this.currentCommandIndex];
    }
}

// Example usage
const terminal = new Terminal('terminal');
terminal.print('Welcome to Dungeon Chase!');
terminal.print('Type "help" for a list of commands.');
terminal.print('');
</script>
</body>
</html>
